code
index.html

const size = 4;
const puzzle = document.getElementById("puzzle");
let tiles = [];
let emptyIndex = size * size - 1;

function createTiles() {
  for (let i = 0; i < size * size; i++) {
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.dataset.index = i;

    const x = (i % size) * 90;
    const y = Math.floor(i / size) * 90;
    tile.style.backgroundPosition = `-${x}px -${y}px`;

    tile.addEventListener("click", () => moveTile(i));
    tiles.push(tile);
  }
}

function shuffle() {
  do {
    tiles.sort(() => Math.random() - 0.5);
  } while (!isSolvable() || isSolved()); // optional, um lösbares Puzzle zu garantieren
  render();
}

function render() {
  puzzle.innerHTML = "";
  tiles.forEach((tile, i) => {
    if (i === emptyIndex) {
      tile.classList.add("empty");
      tile.style.background = "none";
    } else {
      tile.classList.remove("empty");
      const x = (tile.dataset.index % size) * 90;
      const y = Math.floor(tile.dataset.index / size) * 90;
      tile.style.backgroundPosition = `-${x}px -${y}px`;
    }
    puzzle.appendChild(tile);
  });
}

function moveTile(i) {
  const neighbors = [
    emptyIndex - 1, // links
    emptyIndex + 1, // rechts
    emptyIndex - size, // oben
    emptyIndex + size // unten
  ];

  if (neighbors.includes(i)) {
    [tiles[i], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[i]];
    emptyIndex = i;
    render();
  }
}

// Optional: Prüfen, ob Puzzle gelöst ist
function isSolved() {
  for (let i = 0; i < tiles.length; i++) {
    if (tiles[i].dataset.index != i) return false;
  }
  return true;
}

// Optional: Prüfen, ob Puzzle lösbar ist
function isSolvable() {
  let inversions = 0;
  const arr = tiles.map(t => parseInt(t.dataset.index));
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] > arr[j] && arr[i] !== emptyIndex && arr[j] !== emptyIndex) inversions++;
    }
  }
  return inversions % 2 === 0;
}

createTiles();
shuffle();
render();
